import heapq


def take_input():
    n = int(input("Enter the number of vertices in the graph: "))
    graph = {i: [] for i in range(n)}

    print("Enter the edges (vertex1 vertex2 weight):")
    m = int(input("Enter the number of edges: "))
    for _ in range(m):
        u, v, w = map(int, input("Edge (u, v, weight): ").split())
        graph[u].append((v, w))
        graph[v].append((u, w))  

    return graph, n


def prim_mst(graph, n):
    
    mst = []
    visited = [False] * n  
    min_heap = [(0, 0)]  

    total_weight = 0

    while min_heap:
        weight, u = heapq.heappop(min_heap)  

        if visited[u]:
            continue 

        visited[u] = True
        total_weight += weight

        
        if weight != 0:  
            mst.append((u, weight))

       
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(min_heap, (w, v))  

    return mst, total_weight


def main():
    graph, n = take_input()

    mst, total_weight = prim_mst(graph, n)

    
    print("\nMinimum Spanning Tree (MST):")
    for u, weight in mst:
        print(f"Vertex {u} with edge weight {weight}")

    print(f"\nTotal weight of the MST: {total_weight}")

if __name__ == "__main__":
    main()